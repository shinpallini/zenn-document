---
title: "Haskellã§ç«¶æŠ€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ãŒã—ãŸã„ï¼Part4 ç·´ç¿’å•é¡Œã‚’è§£ã(7~9å•ç›®)"
emoji: "ðŸ“Œ"
type: "tech" # tech: æŠ€è¡“è¨˜äº‹ / idea: ã‚¢ã‚¤ãƒ‡ã‚¢
topics: ["Haskell", "Codespaces", "Atcoder", "ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ Ã—æ•°å­¦"]
published: false
---

## ã¯ã˜ã‚ã«
å°‘ã—ãšã¤é€²ã‚“ã§ãã¾ã—ãŸã­ã€‚ã“ã®èª¿å­ã§é ‘å¼µã‚Šã¾ã™ï¼
ã•ã¦ä»Šå›žã¯7~9å•ç›®ã«ã¤ã„ã¦å›žç­”ã—ã¦ã¿ã¾ã—ã‚‡ã†ã€‚
https://atcoder.jp/contests/math-and-algorithm/tasks

## 7å•ç›®
### å•é¡Œ
N ä»¥ä¸‹ã®æ­£ã®æ•´æ•°ã®ä¸­ã§ã€X ã®å€æ•°ã¾ãŸã¯ Y ã®å€æ•°ã§ã‚ã‚‹ã‚‚ã®ã®å€‹æ•°ã¯ã„ãã¤ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

### è§£ç­”
```haskell
isMultiple :: Int -> Int -> Int -> Int
isMultiple x y n
    | n `mod` x == 0 || n `mod` y == 0 = 1
    | otherwise = 0

solve :: Int -> Int -> Int -> Int
solve x y n = sum $ map (isMultiple x y) [1..n]

main:: IO ()
main = do
    input <- getLine
    let [n, x, y] = map read (words input) :: [Int]
    print $ solve x y n
```
### è§£èª¬
ã©ã®ã‚ˆã†ã«è¨ˆç®—ã™ã‚‹ã‹è¿·ã£ãŸã®ã§ã™ãŒã€ä»Šå›žæ€ã„ã¤ã„ãŸã®ã¯ã‚¬ãƒ¼ãƒ‰æ¡ä»¶ã‚’ä½¿ã£ãŸå€æ•°åˆ¤å®šã§ã™ã€‚
ã“ã‚Œã‚’ä½¿ã†ã¨é–¢æ•°ã®ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒãƒ³ã‚°ã«ãŠã„ã¦æ¡ä»¶ã‚’æŒ‡å®šã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
`isMultiple`ã¯ã€ä»Šå›žã ã¨`x`ã¾ãŸã¯`y`ã§å‰²ã£ãŸã¨ãã®ã‚ã¾ã‚ŠãŒ0ã®æ™‚ã«1ã‚’è¿”ã—ã€ãã‚Œä»¥å¤–ã®æ™‚ã¯0ã‚’è¿”ã™ã‚ˆã†ã«å®Ÿè£…ã—ã¾ã—ãŸã€‚
æ¬¡ã«ã“ã®é–¢æ•°ã‚’ä½¿ã£ã¦`solve`ã‚’å®Ÿè£…ã—ã¾ã™ã€‚
`1`ã‹ã‚‰`n`ã¾ã§ã«å¯¾ã—ã¦`isMultiple`ã‚’é©ç”¨ã—ã¦`1`ã«ãªã£ãŸã‚‚ã®ã®åˆè¨ˆã‚’ã¨ã‚‹ã¨å€‹æ•°ãŒæ•°ãˆã‚‰ã‚Œãã†ã¨æ€ã„ã¤ãã€
- `map`ã§` [1..n] `ã¾ã§ã®å€¤ã«`isMultiple`ã‚’é©ç”¨ã™ã‚‹
- ã“ã®å‡¦ç†ã®è¿”ã‚Šå€¤ã®ãƒªã‚¹ãƒˆã«`sum`ã—ã¦è¨ˆç®—

ã¨ã—ã¾ã—ãŸã€‚
æœ€å¾Œã«æ¨™æº–å…¥åŠ›ã§ã™ãŒã€å¤‰æ•°ã«å€¤ã‚’Bindã™ã‚‹ã¨ãã‚‚ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒãƒ³ã‚°ãŒä½¿ãˆã¾ã™ã€‚
ãªã®ã§å…¥åŠ›ãŒ3å€‹ã§ã‚ã‚‹ã“ã¨ãŒäº‹å‰ã«ã‚ã‹ã£ã¦ã„ã‚‹ã®ã§ã€` [n, x, y] `ã¨ã—ã¦å€¤ã‚’å—ã‘å–ã‚Œã¾ã—ãŸã€‚

## 8å•ç›®
### å•é¡Œ
èµ¤ãƒ»é’ã®ã‚«ãƒ¼ãƒ‰ãŒå„1 æžšãšã¤ã‚ã‚Šã€ã‚ãªãŸã¯ãã‚Œãžã‚Œã®ã‚«ãƒ¼ãƒ‰ã« 1 ä»¥ä¸Š N ä»¥ä¸‹ã®æ•´æ•°ã‚’ 1 ã¤æ›¸ãè¾¼ã¿ã¾ã™ã€‚
ã‚«ãƒ¼ãƒ‰ã«æ›¸ã‹ã‚ŒãŸæ•´æ•°ã®åˆè¨ˆãŒ S ä»¥ä¸‹ã¨ãªã‚‹æ›¸ãæ–¹ã¯ã€ã„ãã¤ã‚ã‚Šã¾ã™ã‹ï¼Ÿ
### è§£ç­”
```haskell
solve :: Int -> Int -> Int
solve n s = sum [1 | i <- [1..n], j <- [1..n], i + j <= s]

main:: IO ()
main = do
    input <- getLine
    let [n, s] = map read (words input) :: [Int]
    print $ solve n s
```
### è§£èª¬
ç·å½“ãŸã‚Šã§è¨ˆç®—ã—ãŸã‹ã£ãŸã®ã§ãƒªã‚¹ãƒˆå†…åŒ…è¡¨è¨˜ã‚’ä½¿ã„ã¾ã—ãŸã€‚
å†…åŒ…è¡¨è¨˜ã¨ã¯ã‚‚ã¨ã‚‚ã¨æ•°å­¦ã®é›†åˆã«é–¢ã™ã‚‹ä»•çµ„ã¿ã§ã€æ—¢å­˜ã®é›†åˆã‹ã‚‰æ–°ãŸãªé›†åˆã‚’ä½œã‚‹ãŸã‚ã«ä½¿ã‚ã‚Œã‚‹ãã†ã§ã™ã€‚[1]
ä»Šå›žã¯2ç¨®é¡žã®ã‚«ãƒ¼ãƒ‰ãŒã‚ã‚Šã€ãã‚Œãžã‚Œæœ€å¤§`n`ã¾ã§ã®å€¤ã‚’ã¨ã‚‹ã®ã§ã€ãã‚Œãžã‚Œã®ã‚«ãƒ¼ãƒ‰ãŒã¨ã‚‹æ•°å­—ã®é›†åˆã€ã¤ã¾ã‚Šãƒªã‚¹ãƒˆã¯` [1..n] `ã§è¡¨ç¾ã™ã‚‹ã“ã¨ãŒã§ãã¾ã™ã€‚
ã¾ãŸã“ã®å†…åŒ…è¡¨è¨˜ã«ã¯æ¡ä»¶ã‚’è¨­å®šã™ã‚‹ã“ã¨ãŒã§ãã€ã“ã®æ¡ä»¶ãŒ`True`ã«ãªã£ãŸã‚‚ã®ã ã‘æ–°ã—ã„ãƒªã‚¹ãƒˆã«è¿½åŠ ã•ã‚Œã¾ã™ã€‚
ä»Šå›žã¯`s`ä»¥ä¸‹ãŒæ¡ä»¶ãªã®ã§ã€2ç¨®é¡žã®ã‚«ãƒ¼ãƒ‰ã®æ•°å­—ã®åˆè¨ˆ`i+j`ãŒ`s`ä»¥ä¸‹ãªã‚‰`True`ã¨ãªã‚Šãƒªã‚¹ãƒˆã«`1`ãŒè¿½åŠ ã•ã‚Œã¾ã™ã€‚
æœ€å¾Œã«ã“ã®å‡¦ç†ã«ã‚ˆã£ã¦æ–°ã—ã„ãƒªã‚¹ãƒˆãŒç”Ÿæˆã•ã‚Œã‚‹ã®ã§ã€`sum`ã—ã¦çµ„ã¿åˆã‚ã›ã®æ•°ã‚’åˆè¨ˆã—ã¦ã„ã¾ã™ã€‚

æ¨™æº–å…¥åŠ›ã¯å‰ã®ã‚‚ã®ã¨åŒæ§˜ã«ãƒ‘ã‚¿ãƒ¼ãƒ³ãƒžãƒƒãƒãƒ³ã‚°ã§å¤‰æ•°ã«Bindã—ã¾ã—ãŸã€‚

## 9å•ç›®

### å•é¡Œæ–‡ã«ã‚ã£ãŸæ³¨æ„æ›¸ã
å…¨æŽ¢ç´¢ã§è§£ã„ã¦ã‚‚ 1000 ç‚¹ä¸­ 500 ç‚¹ã—ã‹å¾—ã‚‰ã‚Œãšã€æº€ç‚¹ï¼ˆACï¼‰ã«ãªã‚‰ãªã„ã“ã¨ã«æ³¨æ„ã—ã¦ãã ã•ã„ã€‚ï¼ˆæœ¬ã«è¨˜ã•ã‚Œã¦ã„ã‚‹é€šã‚Šã€ä¸€éƒ¨ã®å¤§ãã„ã‚±ãƒ¼ã‚¹ã§ã¯ç¾å®Ÿçš„ãªæ™‚é–“ã§ç­”ãˆãŒæ±‚ã¾ã‚‰ãªã„ã‹ã‚‰ã§ã™ï¼‰

### å•é¡Œ
N æžšã®ã‚«ãƒ¼ãƒ‰ãŒæ¨ªä¸€åˆ—ã«ä¸¦ã¹ã‚‰ã‚Œã¦ã„ã¾ã™ã€‚å·¦ã‹ã‚‰i ç•ªç›® 
$${{(1â‰¤iâ‰¤N)}}$$ ã®ã‚«ãƒ¼ãƒ‰ã«ã¯æ•´æ•° $${{A_i}}$$ãŒæ›¸ã‹ã‚Œã¦ã„ã¾ã™ã€‚
ã‚«ãƒ¼ãƒ‰ã®ä¸­ã‹ã‚‰ã„ãã¤ã‹ã‚’é¸ã‚“ã§ã€åˆè¨ˆãŒã¡ã‚‡ã†ã© S ã¨ãªã‚‹ã‚ˆã†ã«ã™ã‚‹æ–¹æ³•ã¯ã‚ã‚Šã¾ã™ã‹ã€‚
### è§£ç­”
```haskell
intToBits :: Int -> [Bool]
intToBits 0 = []
intToBits n = (n `mod` 2 == 1) : intToBits (n `div` 2)

genBits :: Int -> [[Bool]]
genBits n = [intToBits i | i <- [1..2^n-1]]

selectedSum :: [Int] -> [Bool] -> Int
selectedSum nums bits = sum $ zipWith (\b x -> if b then x else 0) bits nums

check :: Int -> [Int] -> [Bool] -> Bool
check s nums bits = s == selectedSum nums bits

output :: Bool -> String
output bool = if bool then "Yes" else "No"

main:: IO ()
main = do
    input <- getLine
    let [n, s] = map read (words input) :: [Int]
    input <- getLine
    let nums = map read (words input) :: [Int]
    let allBits = genBits n
    putStrLn $ output $ any (==True) $ map (check s nums) allBits
```
### è§£èª¬

## çµ‚ã‚ã‚Šã«

## å‚è€ƒ
å†…åŒ…è¡¨è¨˜ã§å‚è€ƒã«ãªã£ãŸè¨˜äº‹

https://zenn.dev/masahiro_toba/articles/67c1b3c9e3b809